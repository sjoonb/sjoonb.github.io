---
layout: post
title:  "HTTP"
categories: network
date:   2022-11-29 11:34:23 +0900
---

- [HTTP 란](#http-란)
- [트랜잭션](#트랜잭션)
- [URI](#uri)
- [메시지](#메시지)
- [메서드](#메서드)
- [상태 코드](#상태-코드)
- [HTTP 커넥션 관리](#http-커넥션-관리)
    - [HTTP/1.0+의 Keep-Alive 커넥션](#http10의-keep-alive-커넥션)
    - [HTTP/1.1의 지속 커넥션](#http11의-지속-커넥션)
    - [우아한 커넥션 끊기](#우아한-커넥션-끊기)


<br/>
#  HTTP 란

 Hypertext Transfer Protocol 의 약자이다. `Hypertext` 를 전송하는 약속이라는 것인데, 그렇다면 `Hypertext` 는 무엇일까?


> Hypertext is text displayed on a computer display or other electronic devices with references (hyperlinks) to other text that the reader can immediately access

간단하게, 인터넷에서 사용되는 문서라고 봐도 될 것 같다. 

> HTTP (Hypertext Transfer Protocol) is the set of rules for transferring files -- such as text, images, sound, video and other multimedia files -- over the web

즉, `HTTP` 는 텍스트, 이미지, 동영상 등의 다양한 multimiedia files 를 web 을 통해 전송하는 규칙들의 집합이다.

 `HTTP` 는 신뢰성 있는 데이터 전송 프로토콜 [TCP/IP]({% post_url 2022-11-29-tcp-ip %}) 를 사용하며, 데이터가 지구 반대편에서 오더라도, 전송 중 손상되거나 꼬이지 않음을 보장한다. 따라서, 이를 활용하는 사람들은 인터넷의 결함이나 약점에 대한 걱정없이 애플리케이션 고유의 기능을 구현하는데 집중할 수 있다.


<br/>
# 트랜잭션

 전송 과정의 주체는 결국 크게 송신자, 수신자로 나뉘어 지는데, 이를 각각 클라이언트와 서버라고 부른다. 클라이언트는 주로 `URI` 를 통해 서버의 자원에 접근하며, 다양한 HTTP 메서드를 호출하여 원하는 동작을 수행한다.
  
 클라이언트와 서버가 요청과 응답을 통해 데이터를 주고 받으며 상호작용하는 것을 **트랜잭션**이라고 부른다. 

<br/>
# URI

uniform resource identifier 의 약자이며, 한번 더 `URL`, `URN` 으로 구분지을 수 있다. 그 중 주로 쓰이는  것은 `URL` (uniform resource locator)로, [https://www.google.com](https://www.google.com) 와 같이, 흔히 볼 수 있는 형태이다. 오늘날 대부분의 `URI`는 `URL`이다.

<br/>

# 메시지

요쳥과 응답 메시지의 형태는 3가지로 분류된다.


![httpMessage](/asset/images/httpMessage.png){:class="img-responsive"}

- Start line 
- Headers 
- Body

각 메시지 헤더는 CRLF로 끝난다.

<br/>
# 메서드

서버에게 어떤 동작이 취해져야 하는지 요청하는 방법으로, 위 request 메시지의 Start line 에서 확인할 수 있다. 대표적으로 쓰이는 2가지 메서드는 다음과 같다.

- GET - 서버에게 리소스를 달라고 요청하기 위해 사용된다.
- POST - 서버에 입력 데이터를 전송하는데 사용된다.

<br/>
# 상태 코드

클라이언트에게 요청 후 결과에 대하여 설명해주는 코드로, response 메시지의 Start line 에서 확인할 수 있다. 대표적으로 쓰이는 상태코드는 다음과 같다.

- 200 - OK, 요청 성공을 의미한다.
- 302 - Found, 요청한 resoure 가 임시로 옮겨졌으니, 다른 곳에서 가져가라. 
- 4xx
  - 400 - Bad Request, 클라이언트가 잘못된 요청을 보냈음을 알려준다.
  - 404 - Not found, 요청한 URL이 존재지 않는다는 것을 알려준다.
- 500 - Internal Server Error, 서버 내부에서 에러가 발생하였음을 의미한다.


<br/>
# HTTP 커넥션 관리
[TCP 성능에 대한 고려]({% post_url 2022-11-29-tcp-ip %}#tcp-성능에-대한-고려)에서 확인할 수 있듯이, 대부분의 HTTP 지연은 TCP 네트워크 지연 때문에 발생하며, HTTP에는 이를 개선할 수 있는 여러 기술들이 존재한다.
- parallel connection <br/>
  여러개의 커넥션을 병렬적으로 연결하는 방식이다. 이는 서버의 성능을 크게 떨어트릴 가능성이 있어, 서버는 특정 클라이언트로부터 과도한 수의 커넥션이 맺어졌을 경우, 그것을 임의로 끊어 버리기도 한다. 

  > How many parallel requests can chrome handle?
While Chrome can only handle 10 requests at a time, Firefox can handle up to 17. For an up to date listing of network specifications for browsers, or to check your own browser, visit Browser Scope.
 
  2022년 기준 Chrome은 10개, Firefox 는 17개의 병렬 커넥션만을 허용한다.
  
- persistent connection (지속 커넥션) <br/>
   한 웹페이지에 첨부된 이미지 혹은 하이퍼링크들은 대부은 같은 웹 사이트에 존재하며, 따라서 이후 요청도 같은 서버에 요청하게 될 가능성이 높다. 이러한 속성을 `site locality` 라고 부른다. 

   HTTP/1.1 을 지원하는 기기는 위 속성을 고려하여, TCP 지속 커넥션을 적용한다. 각 처리가 끝날 때마다 커넥션을 닫는 비지속 커넥션과는 달리, 지속 커넥션은 클라이언트나 서버가 직접 커넥션을 끊기 전까지 커넥션이 유지된다. 지속 커넥션을  재사용함으로써, 새로운 커넥션에 소요되는 시간을 절약할 수 있음은 물론, 이미 튜닝된 상태의 커넥션을 사용할 수 있어 더 빠르게 데이터를 전송할 수 있다.


병렬 커넥션은 각 트랜잭션마다 새로운 커넥션을 맺고 끊기 때문에 시간과 대역폭이 소요되고, TCP의 느린시작에 의하여 성능이 떨어지며, 실제로 연결할 수 있는 커넥션 수의 제한도 존재한다.

이에 비하여 지속 커넥션은 커넥션을 맺는 작업과 지연을 줄여주고, 튜닝된 커넥션을 유지한다. 

사실, 지속 커넥션은 병렬 커넥션과 함께 사용될 때 효과적이다. 오늘날 많은 웹 애플리케이션은 적은 수의 병렬 커넥션을 맺고 그것을 유지한다. 두 가지 지속 커넥션 타입이 있는데, `HTTP/1.0+`에는 `keep-alive` 커넥션이 있고, `HTTP/1.1` 에는 `지속 커넥션`이 존재한다.


<br/>
### HTTP/1.0+의 Keep-Alive 커넥션

1996년경에 시작된 이 초기 지속 커넥션은 상호 운용과 관련된 설계의 문제가 있어, 이에 사용되는 `keep-alive` 동작은 `HTTP/1.1` 명세에서 빠졌다. 하지만, 아직 많은 클라이언트와 서버는 이 초기 `keep-alive` 커넥션을 사용하고 있기 때문에 이에 대하여 알아둘 필요가 있다.

- Keep-Alive <br/>
  HTTP/1.0 keep-alive 커넥션을 구현한 클라이언트는 커넥션을 유지하기 위해 Connection:Keep-Alive 헤더를 포함시키며, 이 요청을 받은 서버는 같은 헤더를 응답 메시지에 포함시켜 허락한다. 응답에 해당 헤더가 존재하지 않는다면, 클라이언트는 서버가 커넥션을 끊을 것이라고 추정한다.

Keep-Alive 헤더는 커넥선 유지를 바라는 요청일 뿐이며, 클라이언트나 서버가 이 요청을 받았다고 꼭 이를 지킬 필요는 없다.

keep-alive 커넥션에 대한 몇가지 제한과 사용방법이 존재한다. 
- 커넥션을 계속 유지하려면 모든 메시지에 Conenction:Keep-Alive 요청 헤더를 보내야 한다.
- 서버는 클라이언트가 Keep-Alive 헤더를 보내지 않으면, 요청을 처리한 후 커넥션을 끊을 것이다.
- 클라이언트는 Keep-Alive 헤더가 없는 것을 보고, 서버가 요청을 처리한 후에 커넥션을 끊을 것임을 알 수 있다. 
- 커넥션이 끊어지기 전에 엔티티 본문의 길이를 알 수 있어야 커넥션을 유지할 수 있다. 이 말은 정확한 Content-Length 와 멀티파트 미디어 형식을 가지거나, [chunked transfer encoding]({% post_url 2022-11-30-chunked-transfer-encoding %}) 으로 인코드 되어야 함을 의미한다.
- 클라이언트는 응답 전체를 모두 받기 전에 커넥션이 끊어질 경우를 대비하를, 요청을 다시 보낼 수 있어야 한다.

문제는, Connection 헤더를 전혀 이해하지 못하는 `dumb proxy`로부터 발생한다. dumb proxy 는 이해하지 못한 헤더를 그대로 전달하게 되고, 서버와 클라이언트는 커넥션이 지속될것이라는 약속을 서로에게 받았다고 착각하게 된다. 서버는 커넥션을 끊지 않게 되고, dumb proxy 는 이를 계속 기다린다. 응답을 받은 클라이언트는 새로운 요청을 보내지만, 프락시는 같은 커넥션상에서 다른 요청이 오는 경우는 예상하지 못하기 때문에 이를 무시하게 된다. 이런 잘못된 통신 때문에, 브라우저는 자신이나 서버가 타임아웃이 나서 커넥션이 끊길 때까지 기다리게 된다.

이를 해소하기 위해 영리한 프락시가 `Proxy-Connection` 헤더가 도입되었지만, 이 마저도 네트워크 중간에 dumb proxy 가 하나라도 존재하면 똑같은 문제가 발생하기 때문에 온전한 해결책이라고 볼 수 없다. 


<br/>
### HTTP/1.1의 지속 커넥션

`HTTP/1.1` 에서는 keep-alive 커넥션을 지원하지 않는 대신, 설계가 더 개선된 `지속 커넥션`을 지원하며, 별도 설정을 하지 않는 한 모든 커넥션을 지속 커넥션으로 취급한다. HTTP/1.1 을 사용하는 애플리케이션은 트랜잭션이 끝난 다음 커넥션을 끊으려면 `Connection:close` 헤더를 명시해야 한다.
  
  HTTP/1.1 클라이언트는 응답에 위 헤더가 없으면 커넥션을 계속 유지하는 것으로 추정한다. 하지만 클라이언트와 서버는 언제든 커넥션을 끊을 수 있다. 이를 보내지 않았다고 서버가 영원히 커넥션을 유지하겠다는 것을 뜻하지는 않는다.

  지속 커넥션과 관련된 몇가지 제한과 사용방법이 존재한다.

  - 클라이언트는 해당 커넥션으로 추가적인 요청을 보내지 않을 것이라면, 마지막 요청에 Connection: close 헤더를 보내야 한다.
  - 커넥션이 끊어지기 전에 엔티티 본문의 길이를 알 수 있어야 커넥션을 유지할 수 있다. 이 말은 정확한 Content-Length 와 멀티파트 미디어 형식을 가지거나, [chunked transfer encoding]({% post_url 2022-11-30-chunked-transfer-encoding %}) 으로 인코드 되어야 함을 의미한다.
  - 서버는 메시지를 전송하는 중간에 커넥션을 끊지 않을 것이고, 적어도 끊기 전에 한 개의 요청에 대하여 응답할 것이다. 하지만, HTTP/1.1 기기는 Connection 헤더값과는 상관 없이 언제든지 커넥션을 끊을 수 있다.
  - 클라이언트는 응답 전체를 모두 받기 전에 커넥션이 끊어질 경우를 대비하여, 요청을 다시 보낼 수 있어야 한다.
  - 하나의 클라이언트는 서버의 과부하 방지를 위해 넉넉잡아 2개의 지속 커넥션만을 유지해야한다. 즉, N명의 클라이언트가 서버에 접근한다면, 프락시는 상위 서버나 프락시에 넉넉잡아 약 2N개의 커넥션을 유지해야 한다.

<br/>
**pipelining connection** 

HTTP/1.1은 지속 커넥션을 통해서 요청을 pipelining 할 수 있다.

![pipelining-connection](/asset/images/pipelining-connection.png){:class="img-responsive"}

몇가지 제약 사항은 다음과 같다.

- HTTP 클라이언트는 커넥션이 지속 커넥션인지 확인하기 전까지는 파이프라인을 이어서는 안된다.
- HTTP 메시지에는 순번이 매겨져 있지 않기 때문에, 응답은 요청 순서와 같게 와야한다.
- 클라이언트는 응답 전체를 모두 받기 전에 커넥션이 끊어질 경우를 대비하여, 요청을 다시 보낼 수 있어야 한다.
- 에러가 발생할 경우, 파이프라인 중 어떤 요청이 서버에서 처리되었는지 알 수 없다. 이러한 이유로, 클라이언트는 POST 와 같은 비멱등 요청은 파이프 라인을 통해서 보내선 안된다.


<br/>
### 우아한 커넥션 끊기

TCP 커넥션은 양방향으로 연결되며, 서버와 클라이언트는 각각 하나의 입력 큐와 출력 큐를 가지고 있다. 각 주체는 입력 채널과 출력 채널을 하나만 끊을 수도, 모두 끊을 수도 있다. 

단순한 HTTP 애플리케이션은 전체 끊기만 가능하다. 하지만, 애플리케이션이 각기 다른 노드들과 통신할 때, 그리고 그들과 `파이프라인 지속 커넥션`을 사용할 때엔 기기들이 예상치 못한 쓰기 에러를 발생하는 것을 예방하기 위해 `절반 끊기`를 사용해야 한다.

그 중 입력 채널을 끊는 것은 위험하다. 만약 클라이언트에서 이미 끊긴 입력 채널에 데이터를 전송하면, 서버의 운영체제는 TCP `connection reset by peer` 메시지를 클라이언트에게 보내게 되며, 대부분 운영체제는 이를 심각한 에러로 취급하여, 입력 버퍼에 읽히지 않은 데이를 모두 삭제한다. 이러한 상황은 파이프라인 지속 커넥션에서는 더욱 악화된다.

일반적으로 애플리케이션이 **우아한 커넥션 끊기**를 구현하는 것은 애플리케이션 자신의 출력 채널을 먼저 끊고, 다른 쪽에 있는 기기의 출력 채널이 끊기는 것을 기다리는 것이다. 양쪽에서 더는 데이터를 전송하지 않을 것을 확인하면, 커넥션은 리셋의 위험 없이 온전히 종료된다.